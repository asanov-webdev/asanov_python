1) Pep (о коде)
2) PIP - Python Index Package (место, где хранятся разные пакеты с их версиями, 
устанавливать через команду "pip install ____ ____"; это не единственные метод установки пакетов)

Виртуальная среда (venv от virtual environment) - свой собственный Питон для проекта со своим набором библиотек.
Позволяет работать с несколькими проектами одновременно на разных версиях Питона. 

Вызов функции - отдельная операция, которую нужно выполнять определённым образом (ставить скобки).
print (locals()) , а не print (locals)
locals - все объявленные локальные переменные

Можем умножать строку на число и получать новую строку. Это происходит благодаря возможности переопределить 
оператор для любого объекта.
class A:
	def __mult__(self, x):
		return ...
То есть объект класса А я могу умножить на x и получить что-то (что стоит на месте многоточия).

Аннотация через @ (что это?)

Списки в Питоне используют утиную типизацию (всё равно что list object'ов).
[] - изменяемый список, () - неизменяемый список
В Питоне переопределён оператор обращения к элементу словаря. Например, для словаря dict можно обратиться к значению
элемента по имени "a" как dict["a"].

Что будет в ближайшее время:
- задачи по обработке файлов
- pyGame
- парсер из web (своими руками и готовый)

Аналог else - elif

Пустой оператор - pass

range(a) - все числа до "a"
range(a,b) - все числа от "а" до "b"
range(a,b,c) - все числа от "a" до "b" с шагом "c"

range занимает память, т.к. это список. Поэтому придумали xrange. Это во втором Питоне.
В третьем Питоне есть только range, который работает как xrange.

Длина списка: len(list)
Это то же самое, что и list.__len__()

list[-1] - последний элемент списка

Swaroop - A Byte of Python

kwargs

Через dir можно посмотреть все методы и аттрибуты класса. 
Те, что с двойным нижним подчёркиванием с обеих сторон, описывают поведение при вызове этих методов с элементом класса
в качестве аргумента. __*название метода*__ - так называемый встроенный метод.

Питон - ссылочный язык.
Если нужно просто копирование, используем двоеточие. Копируются списки, строки, кортежи.
1-ый вариант: 
a = [1, 2, 3]
b[2] = 100
a[2] == 100 (true)
2-ой вариант:
a = [1, 2, 3]
a = b[:]
a[2] = 100
b == [1, 2, 3]

1 in lst - проверяем, есть ли 1 в списке.

Проверка на равенство (по логике): ==
Проверка на ссылочное равенство: is
s = [1,2,3]
s2 = [1,2,3]
s == s2 даёт true
s is s2 даёт false

Про работу со множествами: 
- есть в одном, нет в другом
union объединение
intersection пересечение

Работа со словарями:
d = {}
d[2] = 4
d["a"] = A

for k in d.keys
	print d[k]

for k,v in 
